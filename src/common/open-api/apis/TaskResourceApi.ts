/* tslint:disable */
/* eslint-disable */
/**
 * Conductor API Server
 * Conductor API Server
 *
 * The version of the OpenAPI document: v0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    ExternalStorageLocation,
    ExternalStorageLocationFromJSON,
    ExternalStorageLocationToJSON,
    PollData,
    PollDataFromJSON,
    PollDataToJSON,
    SearchResultTask,
    SearchResultTaskFromJSON,
    SearchResultTaskToJSON,
    SearchResultTaskSummary,
    SearchResultTaskSummaryFromJSON,
    SearchResultTaskSummaryToJSON,
    Task,
    TaskFromJSON,
    TaskToJSON,
    TaskExecLog,
    TaskExecLogFromJSON,
    TaskExecLogToJSON,
    TaskResult,
    TaskResultFromJSON,
    TaskResultToJSON,
} from '../models';

export interface BatchPollRequest {
    tasktype: string;
    workerid?: string;
    domain?: string;
    count?: number;
    timeout?: number;
}

export interface GetExternalStorageLocation1Request {
    path: string;
    operation: string;
    payloadType: string;
}

export interface GetPollDataRequest {
    taskType: string;
}

export interface GetTaskRequest {
    taskId: string;
}

export interface GetTaskLogsRequest {
    taskId: string;
}

export interface LogRequest {
    taskId: string;
    body: string;
}

export interface PollRequest {
    tasktype: string;
    workerid?: string;
    domain?: string;
}

export interface RequeuePendingTaskRequest {
    taskType: string;
}

export interface SearchRequest {
    start?: number;
    size?: number;
    sort?: string;
    freeText?: string;
    query?: string;
}

export interface SearchV21Request {
    start?: number;
    size?: number;
    sort?: string;
    freeText?: string;
    query?: string;
}

export interface Size1Request {
    taskType?: Array<string>;
}

export interface UpdateTaskRequest {
    workflowId: string;
    taskRefName: string;
    status: UpdateTaskStatusEnum;
    requestBody: { [key: string]: object; };
}

export interface UpdateTask1Request {
    taskResult: TaskResult;
}

/**
 * 
 */
export class TaskResourceApi extends runtime.BaseAPI {

    /**
     * Get the details about each queue
     */
    async allRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<{ [key: string]: number; }>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Authorization"] = this.configuration.apiKey("X-Authorization"); // api_key authentication
        }

        const response = await this.request({
            path: `/api/tasks/queue/all`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Get the details about each queue
     */
    async all(initOverrides?: RequestInit): Promise<{ [key: string]: number; }> {
        const response = await this.allRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get the details about each queue
     */
    async allVerboseRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<{ [key: string]: { [key: string]: { [key: string]: number; }; }; }>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Authorization"] = this.configuration.apiKey("X-Authorization"); // api_key authentication
        }

        const response = await this.request({
            path: `/api/tasks/queue/all/verbose`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Get the details about each queue
     */
    async allVerbose(initOverrides?: RequestInit): Promise<{ [key: string]: { [key: string]: { [key: string]: number; }; }; }> {
        const response = await this.allVerboseRaw(initOverrides);
        return await response.value();
    }

    /**
     * Batch poll for a task of a certain type
     */
    async batchPollRaw(requestParameters: BatchPollRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Array<Task>>> {
        if (requestParameters.tasktype === null || requestParameters.tasktype === undefined) {
            throw new runtime.RequiredError('tasktype','Required parameter requestParameters.tasktype was null or undefined when calling batchPoll.');
        }

        const queryParameters: any = {};

        if (requestParameters.workerid !== undefined) {
            queryParameters['workerid'] = requestParameters.workerid;
        }

        if (requestParameters.domain !== undefined) {
            queryParameters['domain'] = requestParameters.domain;
        }

        if (requestParameters.count !== undefined) {
            queryParameters['count'] = requestParameters.count;
        }

        if (requestParameters.timeout !== undefined) {
            queryParameters['timeout'] = requestParameters.timeout;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Authorization"] = this.configuration.apiKey("X-Authorization"); // api_key authentication
        }

        const response = await this.request({
            path: `/api/tasks/poll/batch/{tasktype}`.replace(`{${"tasktype"}}`, encodeURIComponent(String(requestParameters.tasktype))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(TaskFromJSON));
    }

    /**
     * Batch poll for a task of a certain type
     */
    async batchPoll(requestParameters: BatchPollRequest, initOverrides?: RequestInit): Promise<Array<Task>> {
        const response = await this.batchPollRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the last poll data for all task types
     */
    async getAllPollDataRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<Array<PollData>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Authorization"] = this.configuration.apiKey("X-Authorization"); // api_key authentication
        }

        const response = await this.request({
            path: `/api/tasks/queue/polldata/all`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(PollDataFromJSON));
    }

    /**
     * Get the last poll data for all task types
     */
    async getAllPollData(initOverrides?: RequestInit): Promise<Array<PollData>> {
        const response = await this.getAllPollDataRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get the external uri where the task payload is to be stored
     */
    async getExternalStorageLocation1Raw(requestParameters: GetExternalStorageLocation1Request, initOverrides?: RequestInit): Promise<runtime.ApiResponse<ExternalStorageLocation>> {
        if (requestParameters.path === null || requestParameters.path === undefined) {
            throw new runtime.RequiredError('path','Required parameter requestParameters.path was null or undefined when calling getExternalStorageLocation1.');
        }

        if (requestParameters.operation === null || requestParameters.operation === undefined) {
            throw new runtime.RequiredError('operation','Required parameter requestParameters.operation was null or undefined when calling getExternalStorageLocation1.');
        }

        if (requestParameters.payloadType === null || requestParameters.payloadType === undefined) {
            throw new runtime.RequiredError('payloadType','Required parameter requestParameters.payloadType was null or undefined when calling getExternalStorageLocation1.');
        }

        const queryParameters: any = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        if (requestParameters.operation !== undefined) {
            queryParameters['operation'] = requestParameters.operation;
        }

        if (requestParameters.payloadType !== undefined) {
            queryParameters['payloadType'] = requestParameters.payloadType;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Authorization"] = this.configuration.apiKey("X-Authorization"); // api_key authentication
        }

        const response = await this.request({
            path: `/api/tasks/externalstoragelocation`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ExternalStorageLocationFromJSON(jsonValue));
    }

    /**
     * Get the external uri where the task payload is to be stored
     */
    async getExternalStorageLocation1(requestParameters: GetExternalStorageLocation1Request, initOverrides?: RequestInit): Promise<ExternalStorageLocation> {
        const response = await this.getExternalStorageLocation1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the last poll data for a given task type
     */
    async getPollDataRaw(requestParameters: GetPollDataRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Array<PollData>>> {
        if (requestParameters.taskType === null || requestParameters.taskType === undefined) {
            throw new runtime.RequiredError('taskType','Required parameter requestParameters.taskType was null or undefined when calling getPollData.');
        }

        const queryParameters: any = {};

        if (requestParameters.taskType !== undefined) {
            queryParameters['taskType'] = requestParameters.taskType;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Authorization"] = this.configuration.apiKey("X-Authorization"); // api_key authentication
        }

        const response = await this.request({
            path: `/api/tasks/queue/polldata`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(PollDataFromJSON));
    }

    /**
     * Get the last poll data for a given task type
     */
    async getPollData(requestParameters: GetPollDataRequest, initOverrides?: RequestInit): Promise<Array<PollData>> {
        const response = await this.getPollDataRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get task by Id
     */
    async getTaskRaw(requestParameters: GetTaskRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Task>> {
        if (requestParameters.taskId === null || requestParameters.taskId === undefined) {
            throw new runtime.RequiredError('taskId','Required parameter requestParameters.taskId was null or undefined when calling getTask.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Authorization"] = this.configuration.apiKey("X-Authorization"); // api_key authentication
        }

        const response = await this.request({
            path: `/api/tasks/{taskId}`.replace(`{${"taskId"}}`, encodeURIComponent(String(requestParameters.taskId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TaskFromJSON(jsonValue));
    }

    /**
     * Get task by Id
     */
    async getTask(requestParameters: GetTaskRequest, initOverrides?: RequestInit): Promise<Task> {
        const response = await this.getTaskRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get Task Execution Logs
     */
    async getTaskLogsRaw(requestParameters: GetTaskLogsRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Array<TaskExecLog>>> {
        if (requestParameters.taskId === null || requestParameters.taskId === undefined) {
            throw new runtime.RequiredError('taskId','Required parameter requestParameters.taskId was null or undefined when calling getTaskLogs.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Authorization"] = this.configuration.apiKey("X-Authorization"); // api_key authentication
        }

        const response = await this.request({
            path: `/api/tasks/{taskId}/log`.replace(`{${"taskId"}}`, encodeURIComponent(String(requestParameters.taskId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(TaskExecLogFromJSON));
    }

    /**
     * Get Task Execution Logs
     */
    async getTaskLogs(requestParameters: GetTaskLogsRequest, initOverrides?: RequestInit): Promise<Array<TaskExecLog>> {
        const response = await this.getTaskLogsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Log Task Execution Details
     */
    async logRaw(requestParameters: LogRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.taskId === null || requestParameters.taskId === undefined) {
            throw new runtime.RequiredError('taskId','Required parameter requestParameters.taskId was null or undefined when calling log.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling log.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Authorization"] = this.configuration.apiKey("X-Authorization"); // api_key authentication
        }

        const response = await this.request({
            path: `/api/tasks/{taskId}/log`.replace(`{${"taskId"}}`, encodeURIComponent(String(requestParameters.taskId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Log Task Execution Details
     */
    async log(requestParameters: LogRequest, initOverrides?: RequestInit): Promise<void> {
        await this.logRaw(requestParameters, initOverrides);
    }

    /**
     * Poll for a task of a certain type
     */
    async pollRaw(requestParameters: PollRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Task>> {
        if (requestParameters.tasktype === null || requestParameters.tasktype === undefined) {
            throw new runtime.RequiredError('tasktype','Required parameter requestParameters.tasktype was null or undefined when calling poll.');
        }

        const queryParameters: any = {};

        if (requestParameters.workerid !== undefined) {
            queryParameters['workerid'] = requestParameters.workerid;
        }

        if (requestParameters.domain !== undefined) {
            queryParameters['domain'] = requestParameters.domain;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Authorization"] = this.configuration.apiKey("X-Authorization"); // api_key authentication
        }

        const response = await this.request({
            path: `/api/tasks/poll/{tasktype}`.replace(`{${"tasktype"}}`, encodeURIComponent(String(requestParameters.tasktype))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TaskFromJSON(jsonValue));
    }

    /**
     * Poll for a task of a certain type
     */
    async poll(requestParameters: PollRequest, initOverrides?: RequestInit): Promise<Task> {
        const response = await this.pollRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Requeue pending tasks
     */
    async requeuePendingTaskRaw(requestParameters: RequeuePendingTaskRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.taskType === null || requestParameters.taskType === undefined) {
            throw new runtime.RequiredError('taskType','Required parameter requestParameters.taskType was null or undefined when calling requeuePendingTask.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Authorization"] = this.configuration.apiKey("X-Authorization"); // api_key authentication
        }

        const response = await this.request({
            path: `/api/tasks/queue/requeue/{taskType}`.replace(`{${"taskType"}}`, encodeURIComponent(String(requestParameters.taskType))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Requeue pending tasks
     */
    async requeuePendingTask(requestParameters: RequeuePendingTaskRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.requeuePendingTaskRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * use sort options as sort=<field>:ASC|DESC e.g. sort=name&sort=workflowId:DESC. If order is not specified, defaults to ASC
     * Search for tasks based in payload and other parameters
     */
    async searchRaw(requestParameters: SearchRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<SearchResultTaskSummary>> {
        const queryParameters: any = {};

        if (requestParameters.start !== undefined) {
            queryParameters['start'] = requestParameters.start;
        }

        if (requestParameters.size !== undefined) {
            queryParameters['size'] = requestParameters.size;
        }

        if (requestParameters.sort !== undefined) {
            queryParameters['sort'] = requestParameters.sort;
        }

        if (requestParameters.freeText !== undefined) {
            queryParameters['freeText'] = requestParameters.freeText;
        }

        if (requestParameters.query !== undefined) {
            queryParameters['query'] = requestParameters.query;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Authorization"] = this.configuration.apiKey("X-Authorization"); // api_key authentication
        }

        const response = await this.request({
            path: `/api/tasks/search`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SearchResultTaskSummaryFromJSON(jsonValue));
    }

    /**
     * use sort options as sort=<field>:ASC|DESC e.g. sort=name&sort=workflowId:DESC. If order is not specified, defaults to ASC
     * Search for tasks based in payload and other parameters
     */
    async search(requestParameters: SearchRequest = {}, initOverrides?: RequestInit): Promise<SearchResultTaskSummary> {
        const response = await this.searchRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * use sort options as sort=<field>:ASC|DESC e.g. sort=name&sort=workflowId:DESC. If order is not specified, defaults to ASC
     * Search for tasks based in payload and other parameters
     */
    async searchV21Raw(requestParameters: SearchV21Request, initOverrides?: RequestInit): Promise<runtime.ApiResponse<SearchResultTask>> {
        const queryParameters: any = {};

        if (requestParameters.start !== undefined) {
            queryParameters['start'] = requestParameters.start;
        }

        if (requestParameters.size !== undefined) {
            queryParameters['size'] = requestParameters.size;
        }

        if (requestParameters.sort !== undefined) {
            queryParameters['sort'] = requestParameters.sort;
        }

        if (requestParameters.freeText !== undefined) {
            queryParameters['freeText'] = requestParameters.freeText;
        }

        if (requestParameters.query !== undefined) {
            queryParameters['query'] = requestParameters.query;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Authorization"] = this.configuration.apiKey("X-Authorization"); // api_key authentication
        }

        const response = await this.request({
            path: `/api/tasks/search-v2`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SearchResultTaskFromJSON(jsonValue));
    }

    /**
     * use sort options as sort=<field>:ASC|DESC e.g. sort=name&sort=workflowId:DESC. If order is not specified, defaults to ASC
     * Search for tasks based in payload and other parameters
     */
    async searchV21(requestParameters: SearchV21Request = {}, initOverrides?: RequestInit): Promise<SearchResultTask> {
        const response = await this.searchV21Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get Task type queue sizes
     */
    async size1Raw(requestParameters: Size1Request, initOverrides?: RequestInit): Promise<runtime.ApiResponse<{ [key: string]: number; }>> {
        const queryParameters: any = {};

        if (requestParameters.taskType) {
            queryParameters['taskType'] = requestParameters.taskType;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Authorization"] = this.configuration.apiKey("X-Authorization"); // api_key authentication
        }

        const response = await this.request({
            path: `/api/tasks/queue/sizes`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Get Task type queue sizes
     */
    async size1(requestParameters: Size1Request = {}, initOverrides?: RequestInit): Promise<{ [key: string]: number; }> {
        const response = await this.size1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update a task By Ref Name
     */
    async updateTaskRaw(requestParameters: UpdateTaskRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.workflowId === null || requestParameters.workflowId === undefined) {
            throw new runtime.RequiredError('workflowId','Required parameter requestParameters.workflowId was null or undefined when calling updateTask.');
        }

        if (requestParameters.taskRefName === null || requestParameters.taskRefName === undefined) {
            throw new runtime.RequiredError('taskRefName','Required parameter requestParameters.taskRefName was null or undefined when calling updateTask.');
        }

        if (requestParameters.status === null || requestParameters.status === undefined) {
            throw new runtime.RequiredError('status','Required parameter requestParameters.status was null or undefined when calling updateTask.');
        }

        if (requestParameters.requestBody === null || requestParameters.requestBody === undefined) {
            throw new runtime.RequiredError('requestBody','Required parameter requestParameters.requestBody was null or undefined when calling updateTask.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Authorization"] = this.configuration.apiKey("X-Authorization"); // api_key authentication
        }

        const response = await this.request({
            path: `/api/tasks/{workflowId}/{taskRefName}/{status}`.replace(`{${"workflowId"}}`, encodeURIComponent(String(requestParameters.workflowId))).replace(`{${"taskRefName"}}`, encodeURIComponent(String(requestParameters.taskRefName))).replace(`{${"status"}}`, encodeURIComponent(String(requestParameters.status))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.requestBody,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Update a task By Ref Name
     */
    async updateTask(requestParameters: UpdateTaskRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.updateTaskRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update a task
     */
    async updateTask1Raw(requestParameters: UpdateTask1Request, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.taskResult === null || requestParameters.taskResult === undefined) {
            throw new runtime.RequiredError('taskResult','Required parameter requestParameters.taskResult was null or undefined when calling updateTask1.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Authorization"] = this.configuration.apiKey("X-Authorization"); // api_key authentication
        }

        const response = await this.request({
            path: `/api/tasks`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: TaskResultToJSON(requestParameters.taskResult),
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Update a task
     */
    async updateTask1(requestParameters: UpdateTask1Request, initOverrides?: RequestInit): Promise<string> {
        const response = await this.updateTask1Raw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
    * @export
    * @enum {string}
    */
export enum UpdateTaskStatusEnum {
    InProgress = 'IN_PROGRESS',
    Failed = 'FAILED',
    FailedWithTerminalError = 'FAILED_WITH_TERMINAL_ERROR',
    Completed = 'COMPLETED'
}
