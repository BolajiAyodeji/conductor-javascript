/* tslint:disable */
/* eslint-disable */
/**
 * Conductor API Server
 * Conductor API Server
 *
 * The version of the OpenAPI document: v0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';

export interface Update1Request {
    workflowId: string;
    taskRefName: string;
    status: Update1StatusEnum;
    requestBody: { [key: string]: object; };
}

export interface UpdateByTaskIdRequest {
    workflowId: string;
    taskId: string;
    status: UpdateByTaskIdStatusEnum;
    requestBody: { [key: string]: object; };
}

/**
 * 
 */
export class QueueAdminResourceApi extends runtime.BaseAPI {

    /**
     * Get Queue Names
     */
    async namesRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<{ [key: string]: string; }>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Authorization"] = this.configuration.apiKey("X-Authorization"); // api_key authentication
        }

        const response = await this.request({
            path: `/api/queue/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Get Queue Names
     */
    async names(initOverrides?: RequestInit): Promise<{ [key: string]: string; }> {
        const response = await this.namesRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get the queue length
     */
    async sizeRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<{ [key: string]: number; }>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Authorization"] = this.configuration.apiKey("X-Authorization"); // api_key authentication
        }

        const response = await this.request({
            path: `/api/queue/size`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Get the queue length
     */
    async size(initOverrides?: RequestInit): Promise<{ [key: string]: number; }> {
        const response = await this.sizeRaw(initOverrides);
        return await response.value();
    }

    /**
     * Publish a message in queue to mark a wait task as completed.
     */
    async update1Raw(requestParameters: Update1Request, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.workflowId === null || requestParameters.workflowId === undefined) {
            throw new runtime.RequiredError('workflowId','Required parameter requestParameters.workflowId was null or undefined when calling update1.');
        }

        if (requestParameters.taskRefName === null || requestParameters.taskRefName === undefined) {
            throw new runtime.RequiredError('taskRefName','Required parameter requestParameters.taskRefName was null or undefined when calling update1.');
        }

        if (requestParameters.status === null || requestParameters.status === undefined) {
            throw new runtime.RequiredError('status','Required parameter requestParameters.status was null or undefined when calling update1.');
        }

        if (requestParameters.requestBody === null || requestParameters.requestBody === undefined) {
            throw new runtime.RequiredError('requestBody','Required parameter requestParameters.requestBody was null or undefined when calling update1.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Authorization"] = this.configuration.apiKey("X-Authorization"); // api_key authentication
        }

        const response = await this.request({
            path: `/api/queue/update/{workflowId}/{taskRefName}/{status}`.replace(`{${"workflowId"}}`, encodeURIComponent(String(requestParameters.workflowId))).replace(`{${"taskRefName"}}`, encodeURIComponent(String(requestParameters.taskRefName))).replace(`{${"status"}}`, encodeURIComponent(String(requestParameters.status))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.requestBody,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Publish a message in queue to mark a wait task as completed.
     */
    async update1(requestParameters: Update1Request, initOverrides?: RequestInit): Promise<void> {
        await this.update1Raw(requestParameters, initOverrides);
    }

    /**
     * Publish a message in queue to mark a wait task (by taskId) as completed.
     */
    async updateByTaskIdRaw(requestParameters: UpdateByTaskIdRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.workflowId === null || requestParameters.workflowId === undefined) {
            throw new runtime.RequiredError('workflowId','Required parameter requestParameters.workflowId was null or undefined when calling updateByTaskId.');
        }

        if (requestParameters.taskId === null || requestParameters.taskId === undefined) {
            throw new runtime.RequiredError('taskId','Required parameter requestParameters.taskId was null or undefined when calling updateByTaskId.');
        }

        if (requestParameters.status === null || requestParameters.status === undefined) {
            throw new runtime.RequiredError('status','Required parameter requestParameters.status was null or undefined when calling updateByTaskId.');
        }

        if (requestParameters.requestBody === null || requestParameters.requestBody === undefined) {
            throw new runtime.RequiredError('requestBody','Required parameter requestParameters.requestBody was null or undefined when calling updateByTaskId.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Authorization"] = this.configuration.apiKey("X-Authorization"); // api_key authentication
        }

        const response = await this.request({
            path: `/api/queue/update/{workflowId}/task/{taskId}/{status}`.replace(`{${"workflowId"}}`, encodeURIComponent(String(requestParameters.workflowId))).replace(`{${"taskId"}}`, encodeURIComponent(String(requestParameters.taskId))).replace(`{${"status"}}`, encodeURIComponent(String(requestParameters.status))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.requestBody,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Publish a message in queue to mark a wait task (by taskId) as completed.
     */
    async updateByTaskId(requestParameters: UpdateByTaskIdRequest, initOverrides?: RequestInit): Promise<void> {
        await this.updateByTaskIdRaw(requestParameters, initOverrides);
    }

}

/**
    * @export
    * @enum {string}
    */
export enum Update1StatusEnum {
    InProgress = 'IN_PROGRESS',
    Canceled = 'CANCELED',
    Failed = 'FAILED',
    FailedWithTerminalError = 'FAILED_WITH_TERMINAL_ERROR',
    Completed = 'COMPLETED',
    CompletedWithErrors = 'COMPLETED_WITH_ERRORS',
    Scheduled = 'SCHEDULED',
    TimedOut = 'TIMED_OUT',
    Skipped = 'SKIPPED'
}
/**
    * @export
    * @enum {string}
    */
export enum UpdateByTaskIdStatusEnum {
    InProgress = 'IN_PROGRESS',
    Canceled = 'CANCELED',
    Failed = 'FAILED',
    FailedWithTerminalError = 'FAILED_WITH_TERMINAL_ERROR',
    Completed = 'COMPLETED',
    CompletedWithErrors = 'COMPLETED_WITH_ERRORS',
    Scheduled = 'SCHEDULED',
    TimedOut = 'TIMED_OUT',
    Skipped = 'SKIPPED'
}
