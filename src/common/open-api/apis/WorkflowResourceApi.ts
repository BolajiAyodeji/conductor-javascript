/* tslint:disable */
/* eslint-disable */
/**
 * Conductor API Server
 * Conductor API Server
 *
 * The version of the OpenAPI document: v0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    ExternalStorageLocation,
    ExternalStorageLocationFromJSON,
    ExternalStorageLocationToJSON,
    InlineObject2,
    InlineObject2FromJSON,
    InlineObject2ToJSON,
    InlineObject9,
    InlineObject9FromJSON,
    InlineObject9ToJSON,
    RerunWorkflowRequest,
    RerunWorkflowRequestFromJSON,
    RerunWorkflowRequestToJSON,
    SearchResultWorkflow,
    SearchResultWorkflowFromJSON,
    SearchResultWorkflowToJSON,
    SearchResultWorkflowSummary,
    SearchResultWorkflowSummaryFromJSON,
    SearchResultWorkflowSummaryToJSON,
    SkipTaskRequest,
    SkipTaskRequestFromJSON,
    SkipTaskRequestToJSON,
    Workflow,
    WorkflowFromJSON,
    WorkflowToJSON,
} from '../models';

export interface DeleteRequest {
    workflowId: string;
    archiveWorkflow?: boolean;
}

export interface DecideRequest {
    workflowId: string;
}

export interface GetExecutionStatusRequest {
    workflowId: string;
    includeTasks?: boolean;
}

export interface GetExternalStorageLocationRequest {
    path: string;
    operation: string;
    payloadType: string;
}

export interface GetRunningWorkflowRequest {
    name: string;
    version?: number;
    startTime?: number;
    endTime?: number;
}

export interface GetWorkflowsRequest {
    name: string;
    correlationId: string;
    includeClosed?: boolean;
    includeTasks?: boolean;
}

export interface GetWorkflows1Request {
    name: string;
    requestBody: Array<string>;
    includeClosed?: boolean;
    includeTasks?: boolean;
}

export interface PauseWorkflowRequest {
    workflowId: string;
}

export interface RerunRequest {
    workflowId: string;
    rerunWorkflowRequest: RerunWorkflowRequest;
}

export interface ResetWorkflowRequest {
    workflowId: string;
}

export interface RestartRequest {
    workflowId: string;
    useLatestDefinitions?: boolean;
}

export interface ResumeWorkflowRequest {
    workflowId: string;
}

export interface Retry1Request {
    workflowId: string;
    resumeSubworkflowTasks?: boolean;
}

export interface Search1Request {
    start?: number;
    size?: number;
    sort?: string;
    freeText?: string;
    query?: string;
}

export interface SearchV22Request {
    start?: number;
    size?: number;
    sort?: string;
    freeText?: string;
    query?: string;
}

export interface SearchWorkflowsByTasksRequest {
    start?: number;
    size?: number;
    sort?: string;
    freeText?: string;
    query?: string;
}

export interface SearchWorkflowsByTasksV2Request {
    start?: number;
    size?: number;
    sort?: string;
    freeText?: string;
    query?: string;
}

export interface SkipTaskFromWorkflowRequest {
    workflowId: string;
    taskReferenceName: string;
    skipTaskRequest?: SkipTaskRequest;
}

export interface StartWorkflowRequest {
    inlineObject2: InlineObject2;
}

export interface StartWorkflow1Request {
    name: string;
    inlineObject9: InlineObject9;
    version?: number;
    correlationId?: string;
    priority?: number;
}

export interface Terminate1Request {
    workflowId: string;
    reason?: string;
}

/**
 * 
 */
export class WorkflowResourceApi extends runtime.BaseAPI {

    /**
     * Removes the workflow from the system
     */
    async _deleteRaw(requestParameters: DeleteRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.workflowId === null || requestParameters.workflowId === undefined) {
            throw new runtime.RequiredError('workflowId','Required parameter requestParameters.workflowId was null or undefined when calling _delete.');
        }

        const queryParameters: any = {};

        if (requestParameters.archiveWorkflow !== undefined) {
            queryParameters['archiveWorkflow'] = requestParameters.archiveWorkflow;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Authorization"] = this.configuration.apiKey("X-Authorization"); // api_key authentication
        }

        const response = await this.request({
            path: `/api/workflow/{workflowId}/remove`.replace(`{${"workflowId"}}`, encodeURIComponent(String(requestParameters.workflowId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Removes the workflow from the system
     */
    async _delete(requestParameters: DeleteRequest, initOverrides?: RequestInit): Promise<void> {
        await this._deleteRaw(requestParameters, initOverrides);
    }

    /**
     * Starts the decision task for a workflow
     */
    async decideRaw(requestParameters: DecideRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.workflowId === null || requestParameters.workflowId === undefined) {
            throw new runtime.RequiredError('workflowId','Required parameter requestParameters.workflowId was null or undefined when calling decide.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Authorization"] = this.configuration.apiKey("X-Authorization"); // api_key authentication
        }

        const response = await this.request({
            path: `/api/workflow/decide/{workflowId}`.replace(`{${"workflowId"}}`, encodeURIComponent(String(requestParameters.workflowId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Starts the decision task for a workflow
     */
    async decide(requestParameters: DecideRequest, initOverrides?: RequestInit): Promise<void> {
        await this.decideRaw(requestParameters, initOverrides);
    }

    /**
     * Gets the workflow by workflow id
     */
    async getExecutionStatusRaw(requestParameters: GetExecutionStatusRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Workflow>> {
        if (requestParameters.workflowId === null || requestParameters.workflowId === undefined) {
            throw new runtime.RequiredError('workflowId','Required parameter requestParameters.workflowId was null or undefined when calling getExecutionStatus.');
        }

        const queryParameters: any = {};

        if (requestParameters.includeTasks !== undefined) {
            queryParameters['includeTasks'] = requestParameters.includeTasks;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Authorization"] = this.configuration.apiKey("X-Authorization"); // api_key authentication
        }

        const response = await this.request({
            path: `/api/workflow/{workflowId}`.replace(`{${"workflowId"}}`, encodeURIComponent(String(requestParameters.workflowId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkflowFromJSON(jsonValue));
    }

    /**
     * Gets the workflow by workflow id
     */
    async getExecutionStatus(requestParameters: GetExecutionStatusRequest, initOverrides?: RequestInit): Promise<Workflow> {
        const response = await this.getExecutionStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the uri and path of the external storage where the workflow payload is to be stored
     */
    async getExternalStorageLocationRaw(requestParameters: GetExternalStorageLocationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<ExternalStorageLocation>> {
        if (requestParameters.path === null || requestParameters.path === undefined) {
            throw new runtime.RequiredError('path','Required parameter requestParameters.path was null or undefined when calling getExternalStorageLocation.');
        }

        if (requestParameters.operation === null || requestParameters.operation === undefined) {
            throw new runtime.RequiredError('operation','Required parameter requestParameters.operation was null or undefined when calling getExternalStorageLocation.');
        }

        if (requestParameters.payloadType === null || requestParameters.payloadType === undefined) {
            throw new runtime.RequiredError('payloadType','Required parameter requestParameters.payloadType was null or undefined when calling getExternalStorageLocation.');
        }

        const queryParameters: any = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        if (requestParameters.operation !== undefined) {
            queryParameters['operation'] = requestParameters.operation;
        }

        if (requestParameters.payloadType !== undefined) {
            queryParameters['payloadType'] = requestParameters.payloadType;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Authorization"] = this.configuration.apiKey("X-Authorization"); // api_key authentication
        }

        const response = await this.request({
            path: `/api/workflow/externalstoragelocation`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ExternalStorageLocationFromJSON(jsonValue));
    }

    /**
     * Get the uri and path of the external storage where the workflow payload is to be stored
     */
    async getExternalStorageLocation(requestParameters: GetExternalStorageLocationRequest, initOverrides?: RequestInit): Promise<ExternalStorageLocation> {
        const response = await this.getExternalStorageLocationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve all the running workflows
     */
    async getRunningWorkflowRaw(requestParameters: GetRunningWorkflowRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Array<string>>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling getRunningWorkflow.');
        }

        const queryParameters: any = {};

        if (requestParameters.version !== undefined) {
            queryParameters['version'] = requestParameters.version;
        }

        if (requestParameters.startTime !== undefined) {
            queryParameters['startTime'] = requestParameters.startTime;
        }

        if (requestParameters.endTime !== undefined) {
            queryParameters['endTime'] = requestParameters.endTime;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Authorization"] = this.configuration.apiKey("X-Authorization"); // api_key authentication
        }

        const response = await this.request({
            path: `/api/workflow/running/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Retrieve all the running workflows
     */
    async getRunningWorkflow(requestParameters: GetRunningWorkflowRequest, initOverrides?: RequestInit): Promise<Array<string>> {
        const response = await this.getRunningWorkflowRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Lists workflows for the given correlation id
     */
    async getWorkflowsRaw(requestParameters: GetWorkflowsRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Array<Workflow>>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling getWorkflows.');
        }

        if (requestParameters.correlationId === null || requestParameters.correlationId === undefined) {
            throw new runtime.RequiredError('correlationId','Required parameter requestParameters.correlationId was null or undefined when calling getWorkflows.');
        }

        const queryParameters: any = {};

        if (requestParameters.includeClosed !== undefined) {
            queryParameters['includeClosed'] = requestParameters.includeClosed;
        }

        if (requestParameters.includeTasks !== undefined) {
            queryParameters['includeTasks'] = requestParameters.includeTasks;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Authorization"] = this.configuration.apiKey("X-Authorization"); // api_key authentication
        }

        const response = await this.request({
            path: `/api/workflow/{name}/correlated/{correlationId}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"correlationId"}}`, encodeURIComponent(String(requestParameters.correlationId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(WorkflowFromJSON));
    }

    /**
     * Lists workflows for the given correlation id
     */
    async getWorkflows(requestParameters: GetWorkflowsRequest, initOverrides?: RequestInit): Promise<Array<Workflow>> {
        const response = await this.getWorkflowsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Lists workflows for the given correlation id list
     */
    async getWorkflows1Raw(requestParameters: GetWorkflows1Request, initOverrides?: RequestInit): Promise<runtime.ApiResponse<{ [key: string]: Array<Workflow>; }>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling getWorkflows1.');
        }

        if (requestParameters.requestBody === null || requestParameters.requestBody === undefined) {
            throw new runtime.RequiredError('requestBody','Required parameter requestParameters.requestBody was null or undefined when calling getWorkflows1.');
        }

        const queryParameters: any = {};

        if (requestParameters.includeClosed !== undefined) {
            queryParameters['includeClosed'] = requestParameters.includeClosed;
        }

        if (requestParameters.includeTasks !== undefined) {
            queryParameters['includeTasks'] = requestParameters.includeTasks;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Authorization"] = this.configuration.apiKey("X-Authorization"); // api_key authentication
        }

        const response = await this.request({
            path: `/api/workflow/{name}/correlated`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.requestBody,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Lists workflows for the given correlation id list
     */
    async getWorkflows1(requestParameters: GetWorkflows1Request, initOverrides?: RequestInit): Promise<{ [key: string]: Array<Workflow>; }> {
        const response = await this.getWorkflows1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Pauses the workflow
     */
    async pauseWorkflowRaw(requestParameters: PauseWorkflowRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.workflowId === null || requestParameters.workflowId === undefined) {
            throw new runtime.RequiredError('workflowId','Required parameter requestParameters.workflowId was null or undefined when calling pauseWorkflow.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Authorization"] = this.configuration.apiKey("X-Authorization"); // api_key authentication
        }

        const response = await this.request({
            path: `/api/workflow/{workflowId}/pause`.replace(`{${"workflowId"}}`, encodeURIComponent(String(requestParameters.workflowId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Pauses the workflow
     */
    async pauseWorkflow(requestParameters: PauseWorkflowRequest, initOverrides?: RequestInit): Promise<void> {
        await this.pauseWorkflowRaw(requestParameters, initOverrides);
    }

    /**
     * Reruns the workflow from a specific task
     */
    async rerunRaw(requestParameters: RerunRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.workflowId === null || requestParameters.workflowId === undefined) {
            throw new runtime.RequiredError('workflowId','Required parameter requestParameters.workflowId was null or undefined when calling rerun.');
        }

        if (requestParameters.rerunWorkflowRequest === null || requestParameters.rerunWorkflowRequest === undefined) {
            throw new runtime.RequiredError('rerunWorkflowRequest','Required parameter requestParameters.rerunWorkflowRequest was null or undefined when calling rerun.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Authorization"] = this.configuration.apiKey("X-Authorization"); // api_key authentication
        }

        const response = await this.request({
            path: `/api/workflow/{workflowId}/rerun`.replace(`{${"workflowId"}}`, encodeURIComponent(String(requestParameters.workflowId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RerunWorkflowRequestToJSON(requestParameters.rerunWorkflowRequest),
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Reruns the workflow from a specific task
     */
    async rerun(requestParameters: RerunRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.rerunRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Resets callback times of all non-terminal SIMPLE tasks to 0
     */
    async resetWorkflowRaw(requestParameters: ResetWorkflowRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.workflowId === null || requestParameters.workflowId === undefined) {
            throw new runtime.RequiredError('workflowId','Required parameter requestParameters.workflowId was null or undefined when calling resetWorkflow.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Authorization"] = this.configuration.apiKey("X-Authorization"); // api_key authentication
        }

        const response = await this.request({
            path: `/api/workflow/{workflowId}/resetcallbacks`.replace(`{${"workflowId"}}`, encodeURIComponent(String(requestParameters.workflowId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Resets callback times of all non-terminal SIMPLE tasks to 0
     */
    async resetWorkflow(requestParameters: ResetWorkflowRequest, initOverrides?: RequestInit): Promise<void> {
        await this.resetWorkflowRaw(requestParameters, initOverrides);
    }

    /**
     * Restarts a completed workflow
     */
    async restartRaw(requestParameters: RestartRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.workflowId === null || requestParameters.workflowId === undefined) {
            throw new runtime.RequiredError('workflowId','Required parameter requestParameters.workflowId was null or undefined when calling restart.');
        }

        const queryParameters: any = {};

        if (requestParameters.useLatestDefinitions !== undefined) {
            queryParameters['useLatestDefinitions'] = requestParameters.useLatestDefinitions;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Authorization"] = this.configuration.apiKey("X-Authorization"); // api_key authentication
        }

        const response = await this.request({
            path: `/api/workflow/{workflowId}/restart`.replace(`{${"workflowId"}}`, encodeURIComponent(String(requestParameters.workflowId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Restarts a completed workflow
     */
    async restart(requestParameters: RestartRequest, initOverrides?: RequestInit): Promise<void> {
        await this.restartRaw(requestParameters, initOverrides);
    }

    /**
     * Resumes the workflow
     */
    async resumeWorkflowRaw(requestParameters: ResumeWorkflowRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.workflowId === null || requestParameters.workflowId === undefined) {
            throw new runtime.RequiredError('workflowId','Required parameter requestParameters.workflowId was null or undefined when calling resumeWorkflow.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Authorization"] = this.configuration.apiKey("X-Authorization"); // api_key authentication
        }

        const response = await this.request({
            path: `/api/workflow/{workflowId}/resume`.replace(`{${"workflowId"}}`, encodeURIComponent(String(requestParameters.workflowId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Resumes the workflow
     */
    async resumeWorkflow(requestParameters: ResumeWorkflowRequest, initOverrides?: RequestInit): Promise<void> {
        await this.resumeWorkflowRaw(requestParameters, initOverrides);
    }

    /**
     * Retries the last failed task
     */
    async retry1Raw(requestParameters: Retry1Request, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.workflowId === null || requestParameters.workflowId === undefined) {
            throw new runtime.RequiredError('workflowId','Required parameter requestParameters.workflowId was null or undefined when calling retry1.');
        }

        const queryParameters: any = {};

        if (requestParameters.resumeSubworkflowTasks !== undefined) {
            queryParameters['resumeSubworkflowTasks'] = requestParameters.resumeSubworkflowTasks;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Authorization"] = this.configuration.apiKey("X-Authorization"); // api_key authentication
        }

        const response = await this.request({
            path: `/api/workflow/{workflowId}/retry`.replace(`{${"workflowId"}}`, encodeURIComponent(String(requestParameters.workflowId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Retries the last failed task
     */
    async retry1(requestParameters: Retry1Request, initOverrides?: RequestInit): Promise<void> {
        await this.retry1Raw(requestParameters, initOverrides);
    }

    /**
     * use sort options as sort=<field>:ASC|DESC e.g. sort=name&sort=workflowId:DESC. If order is not specified, defaults to ASC.
     * Search for workflows based on payload and other parameters
     */
    async search1Raw(requestParameters: Search1Request, initOverrides?: RequestInit): Promise<runtime.ApiResponse<SearchResultWorkflowSummary>> {
        const queryParameters: any = {};

        if (requestParameters.start !== undefined) {
            queryParameters['start'] = requestParameters.start;
        }

        if (requestParameters.size !== undefined) {
            queryParameters['size'] = requestParameters.size;
        }

        if (requestParameters.sort !== undefined) {
            queryParameters['sort'] = requestParameters.sort;
        }

        if (requestParameters.freeText !== undefined) {
            queryParameters['freeText'] = requestParameters.freeText;
        }

        if (requestParameters.query !== undefined) {
            queryParameters['query'] = requestParameters.query;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Authorization"] = this.configuration.apiKey("X-Authorization"); // api_key authentication
        }

        const response = await this.request({
            path: `/api/workflow/search`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SearchResultWorkflowSummaryFromJSON(jsonValue));
    }

    /**
     * use sort options as sort=<field>:ASC|DESC e.g. sort=name&sort=workflowId:DESC. If order is not specified, defaults to ASC.
     * Search for workflows based on payload and other parameters
     */
    async search1(requestParameters: Search1Request = {}, initOverrides?: RequestInit): Promise<SearchResultWorkflowSummary> {
        const response = await this.search1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * use sort options as sort=<field>:ASC|DESC e.g. sort=name&sort=workflowId:DESC. If order is not specified, defaults to ASC.
     * Search for workflows based on payload and other parameters
     */
    async searchV22Raw(requestParameters: SearchV22Request, initOverrides?: RequestInit): Promise<runtime.ApiResponse<SearchResultWorkflow>> {
        const queryParameters: any = {};

        if (requestParameters.start !== undefined) {
            queryParameters['start'] = requestParameters.start;
        }

        if (requestParameters.size !== undefined) {
            queryParameters['size'] = requestParameters.size;
        }

        if (requestParameters.sort !== undefined) {
            queryParameters['sort'] = requestParameters.sort;
        }

        if (requestParameters.freeText !== undefined) {
            queryParameters['freeText'] = requestParameters.freeText;
        }

        if (requestParameters.query !== undefined) {
            queryParameters['query'] = requestParameters.query;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Authorization"] = this.configuration.apiKey("X-Authorization"); // api_key authentication
        }

        const response = await this.request({
            path: `/api/workflow/search-v2`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SearchResultWorkflowFromJSON(jsonValue));
    }

    /**
     * use sort options as sort=<field>:ASC|DESC e.g. sort=name&sort=workflowId:DESC. If order is not specified, defaults to ASC.
     * Search for workflows based on payload and other parameters
     */
    async searchV22(requestParameters: SearchV22Request = {}, initOverrides?: RequestInit): Promise<SearchResultWorkflow> {
        const response = await this.searchV22Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * use sort options as sort=<field>:ASC|DESC e.g. sort=name&sort=workflowId:DESC. If order is not specified, defaults to ASC
     * Search for workflows based on task parameters
     */
    async searchWorkflowsByTasksRaw(requestParameters: SearchWorkflowsByTasksRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<SearchResultWorkflowSummary>> {
        const queryParameters: any = {};

        if (requestParameters.start !== undefined) {
            queryParameters['start'] = requestParameters.start;
        }

        if (requestParameters.size !== undefined) {
            queryParameters['size'] = requestParameters.size;
        }

        if (requestParameters.sort !== undefined) {
            queryParameters['sort'] = requestParameters.sort;
        }

        if (requestParameters.freeText !== undefined) {
            queryParameters['freeText'] = requestParameters.freeText;
        }

        if (requestParameters.query !== undefined) {
            queryParameters['query'] = requestParameters.query;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Authorization"] = this.configuration.apiKey("X-Authorization"); // api_key authentication
        }

        const response = await this.request({
            path: `/api/workflow/search-by-tasks`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SearchResultWorkflowSummaryFromJSON(jsonValue));
    }

    /**
     * use sort options as sort=<field>:ASC|DESC e.g. sort=name&sort=workflowId:DESC. If order is not specified, defaults to ASC
     * Search for workflows based on task parameters
     */
    async searchWorkflowsByTasks(requestParameters: SearchWorkflowsByTasksRequest = {}, initOverrides?: RequestInit): Promise<SearchResultWorkflowSummary> {
        const response = await this.searchWorkflowsByTasksRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * use sort options as sort=<field>:ASC|DESC e.g. sort=name&sort=workflowId:DESC. If order is not specified, defaults to ASC
     * Search for workflows based on task parameters
     */
    async searchWorkflowsByTasksV2Raw(requestParameters: SearchWorkflowsByTasksV2Request, initOverrides?: RequestInit): Promise<runtime.ApiResponse<SearchResultWorkflow>> {
        const queryParameters: any = {};

        if (requestParameters.start !== undefined) {
            queryParameters['start'] = requestParameters.start;
        }

        if (requestParameters.size !== undefined) {
            queryParameters['size'] = requestParameters.size;
        }

        if (requestParameters.sort !== undefined) {
            queryParameters['sort'] = requestParameters.sort;
        }

        if (requestParameters.freeText !== undefined) {
            queryParameters['freeText'] = requestParameters.freeText;
        }

        if (requestParameters.query !== undefined) {
            queryParameters['query'] = requestParameters.query;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Authorization"] = this.configuration.apiKey("X-Authorization"); // api_key authentication
        }

        const response = await this.request({
            path: `/api/workflow/search-by-tasks-v2`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SearchResultWorkflowFromJSON(jsonValue));
    }

    /**
     * use sort options as sort=<field>:ASC|DESC e.g. sort=name&sort=workflowId:DESC. If order is not specified, defaults to ASC
     * Search for workflows based on task parameters
     */
    async searchWorkflowsByTasksV2(requestParameters: SearchWorkflowsByTasksV2Request = {}, initOverrides?: RequestInit): Promise<SearchResultWorkflow> {
        const response = await this.searchWorkflowsByTasksV2Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Skips a given task from a current running workflow
     */
    async skipTaskFromWorkflowRaw(requestParameters: SkipTaskFromWorkflowRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.workflowId === null || requestParameters.workflowId === undefined) {
            throw new runtime.RequiredError('workflowId','Required parameter requestParameters.workflowId was null or undefined when calling skipTaskFromWorkflow.');
        }

        if (requestParameters.taskReferenceName === null || requestParameters.taskReferenceName === undefined) {
            throw new runtime.RequiredError('taskReferenceName','Required parameter requestParameters.taskReferenceName was null or undefined when calling skipTaskFromWorkflow.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Authorization"] = this.configuration.apiKey("X-Authorization"); // api_key authentication
        }

        const response = await this.request({
            path: `/api/workflow/{workflowId}/skiptask/{taskReferenceName}`.replace(`{${"workflowId"}}`, encodeURIComponent(String(requestParameters.workflowId))).replace(`{${"taskReferenceName"}}`, encodeURIComponent(String(requestParameters.taskReferenceName))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: SkipTaskRequestToJSON(requestParameters.skipTaskRequest),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Skips a given task from a current running workflow
     */
    async skipTaskFromWorkflow(requestParameters: SkipTaskFromWorkflowRequest, initOverrides?: RequestInit): Promise<void> {
        await this.skipTaskFromWorkflowRaw(requestParameters, initOverrides);
    }

    /**
     * Start a new workflow with StartWorkflowRequest, which allows task to be executed in a domain
     */
    async startWorkflowRaw(requestParameters: StartWorkflowRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.inlineObject2 === null || requestParameters.inlineObject2 === undefined) {
            throw new runtime.RequiredError('inlineObject2','Required parameter requestParameters.inlineObject2 was null or undefined when calling startWorkflow.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Authorization"] = this.configuration.apiKey("X-Authorization"); // api_key authentication
        }

        const response = await this.request({
            path: `/api/workflow`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: InlineObject2ToJSON(requestParameters.inlineObject2),
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Start a new workflow with StartWorkflowRequest, which allows task to be executed in a domain
     */
    async startWorkflow(requestParameters: StartWorkflowRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.startWorkflowRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Start a new workflow. Returns the ID of the workflow instance that can be later used for tracking
     */
    async startWorkflow1Raw(requestParameters: StartWorkflow1Request, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling startWorkflow1.');
        }

        if (requestParameters.inlineObject9 === null || requestParameters.inlineObject9 === undefined) {
            throw new runtime.RequiredError('inlineObject9','Required parameter requestParameters.inlineObject9 was null or undefined when calling startWorkflow1.');
        }

        const queryParameters: any = {};

        if (requestParameters.version !== undefined) {
            queryParameters['version'] = requestParameters.version;
        }

        if (requestParameters.correlationId !== undefined) {
            queryParameters['correlationId'] = requestParameters.correlationId;
        }

        if (requestParameters.priority !== undefined) {
            queryParameters['priority'] = requestParameters.priority;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Authorization"] = this.configuration.apiKey("X-Authorization"); // api_key authentication
        }

        const response = await this.request({
            path: `/api/workflow/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: InlineObject9ToJSON(requestParameters.inlineObject9),
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Start a new workflow. Returns the ID of the workflow instance that can be later used for tracking
     */
    async startWorkflow1(requestParameters: StartWorkflow1Request, initOverrides?: RequestInit): Promise<string> {
        const response = await this.startWorkflow1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Terminate workflow execution
     */
    async terminate1Raw(requestParameters: Terminate1Request, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.workflowId === null || requestParameters.workflowId === undefined) {
            throw new runtime.RequiredError('workflowId','Required parameter requestParameters.workflowId was null or undefined when calling terminate1.');
        }

        const queryParameters: any = {};

        if (requestParameters.reason !== undefined) {
            queryParameters['reason'] = requestParameters.reason;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Authorization"] = this.configuration.apiKey("X-Authorization"); // api_key authentication
        }

        const response = await this.request({
            path: `/api/workflow/{workflowId}`.replace(`{${"workflowId"}}`, encodeURIComponent(String(requestParameters.workflowId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Terminate workflow execution
     */
    async terminate1(requestParameters: Terminate1Request, initOverrides?: RequestInit): Promise<void> {
        await this.terminate1Raw(requestParameters, initOverrides);
    }

}
