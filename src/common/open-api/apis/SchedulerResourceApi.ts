/* tslint:disable */
/* eslint-disable */
/**
 * Conductor API Server
 * Conductor API Server
 *
 * The version of the OpenAPI document: v0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    InlineObject7,
    InlineObject7FromJSON,
    InlineObject7ToJSON,
    SearchResultWorkflowScheduleExecutionModel,
    SearchResultWorkflowScheduleExecutionModelFromJSON,
    SearchResultWorkflowScheduleExecutionModelToJSON,
    WorkflowSchedule,
    WorkflowScheduleFromJSON,
    WorkflowScheduleToJSON,
} from '../models';

export interface DeleteScheduleRequest {
    name: string;
    body?: string;
}

export interface GetAllSchedulesRequest {
    workflowName?: string;
}

export interface GetNextFewSchedulesRequest {
    cronExpression: string;
    scheduleStartTime?: number;
    scheduleEndTime?: number;
    limit?: number;
}

export interface GetScheduleRequest {
    name: string;
}

export interface PauseScheduleRequest {
    userId: string;
    name: string;
}

export interface ResumeScheduleRequest {
    userId: string;
    name: string;
}

export interface SaveScheduleRequest {
    inlineObject7: InlineObject7;
}

export interface SearchV2Request {
    start?: number;
    size?: number;
    sort?: string;
    freeText?: string;
    query?: string;
}

/**
 * 
 */
export class SchedulerResourceApi extends runtime.BaseAPI {

    /**
     * Deletes an existing workflow schedule by name
     */
    async deleteScheduleRaw(requestParameters: DeleteScheduleRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling deleteSchedule.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Authorization"] = this.configuration.apiKey("X-Authorization"); // api_key authentication
        }

        const response = await this.request({
            path: `/api/scheduler/schedules/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Deletes an existing workflow schedule by name
     */
    async deleteSchedule(requestParameters: DeleteScheduleRequest, initOverrides?: RequestInit): Promise<object> {
        const response = await this.deleteScheduleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get all existing workflow schedules and optionally filter by workflow name
     */
    async getAllSchedulesRaw(requestParameters: GetAllSchedulesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Array<WorkflowSchedule>>> {
        const queryParameters: any = {};

        if (requestParameters.workflowName !== undefined) {
            queryParameters['workflowName'] = requestParameters.workflowName;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Authorization"] = this.configuration.apiKey("X-Authorization"); // api_key authentication
        }

        const response = await this.request({
            path: `/api/scheduler/schedules`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(WorkflowScheduleFromJSON));
    }

    /**
     * Get all existing workflow schedules and optionally filter by workflow name
     */
    async getAllSchedules(requestParameters: GetAllSchedulesRequest = {}, initOverrides?: RequestInit): Promise<Array<WorkflowSchedule>> {
        const response = await this.getAllSchedulesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get list of the next x (default 3, max 5) execution times for a scheduler
     */
    async getNextFewSchedulesRaw(requestParameters: GetNextFewSchedulesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Array<number>>> {
        if (requestParameters.cronExpression === null || requestParameters.cronExpression === undefined) {
            throw new runtime.RequiredError('cronExpression','Required parameter requestParameters.cronExpression was null or undefined when calling getNextFewSchedules.');
        }

        const queryParameters: any = {};

        if (requestParameters.cronExpression !== undefined) {
            queryParameters['cronExpression'] = requestParameters.cronExpression;
        }

        if (requestParameters.scheduleStartTime !== undefined) {
            queryParameters['scheduleStartTime'] = requestParameters.scheduleStartTime;
        }

        if (requestParameters.scheduleEndTime !== undefined) {
            queryParameters['scheduleEndTime'] = requestParameters.scheduleEndTime;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Authorization"] = this.configuration.apiKey("X-Authorization"); // api_key authentication
        }

        const response = await this.request({
            path: `/api/scheduler/nextFewSchedules`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Get list of the next x (default 3, max 5) execution times for a scheduler
     */
    async getNextFewSchedules(requestParameters: GetNextFewSchedulesRequest, initOverrides?: RequestInit): Promise<Array<number>> {
        const response = await this.getNextFewSchedulesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get an existing workflow schedule by name
     */
    async getScheduleRaw(requestParameters: GetScheduleRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling getSchedule.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Authorization"] = this.configuration.apiKey("X-Authorization"); // api_key authentication
        }

        const response = await this.request({
            path: `/api/scheduler/schedules/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Get an existing workflow schedule by name
     */
    async getSchedule(requestParameters: GetScheduleRequest, initOverrides?: RequestInit): Promise<object> {
        const response = await this.getScheduleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Pause all scheduling in a single conductor server instance (for debugging only)
     */
    async pauseAllSchedulesRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<{ [key: string]: object; }>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Authorization"] = this.configuration.apiKey("X-Authorization"); // api_key authentication
        }

        const response = await this.request({
            path: `/api/scheduler/admin/pause`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Pause all scheduling in a single conductor server instance (for debugging only)
     */
    async pauseAllSchedules(initOverrides?: RequestInit): Promise<{ [key: string]: object; }> {
        const response = await this.pauseAllSchedulesRaw(initOverrides);
        return await response.value();
    }

    /**
     * Pauses an existing schedule by name
     */
    async pauseScheduleRaw(requestParameters: PauseScheduleRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.userId === null || requestParameters.userId === undefined) {
            throw new runtime.RequiredError('userId','Required parameter requestParameters.userId was null or undefined when calling pauseSchedule.');
        }

        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling pauseSchedule.');
        }

        const queryParameters: any = {};

        if (requestParameters.userId !== undefined) {
            queryParameters['userId'] = requestParameters.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Authorization"] = this.configuration.apiKey("X-Authorization"); // api_key authentication
        }

        const response = await this.request({
            path: `/api/scheduler/schedules/{name}/pause`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Pauses an existing schedule by name
     */
    async pauseSchedule(requestParameters: PauseScheduleRequest, initOverrides?: RequestInit): Promise<object> {
        const response = await this.pauseScheduleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Requeue all execution records
     */
    async requeueAllExecutionRecordsRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<{ [key: string]: object; }>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Authorization"] = this.configuration.apiKey("X-Authorization"); // api_key authentication
        }

        const response = await this.request({
            path: `/api/scheduler/admin/requeue`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Requeue all execution records
     */
    async requeueAllExecutionRecords(initOverrides?: RequestInit): Promise<{ [key: string]: object; }> {
        const response = await this.requeueAllExecutionRecordsRaw(initOverrides);
        return await response.value();
    }

    /**
     * Resume all scheduling
     */
    async resumeAllSchedulesRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<{ [key: string]: object; }>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Authorization"] = this.configuration.apiKey("X-Authorization"); // api_key authentication
        }

        const response = await this.request({
            path: `/api/scheduler/admin/resume`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Resume all scheduling
     */
    async resumeAllSchedules(initOverrides?: RequestInit): Promise<{ [key: string]: object; }> {
        const response = await this.resumeAllSchedulesRaw(initOverrides);
        return await response.value();
    }

    /**
     * Resume a paused schedule by name
     */
    async resumeScheduleRaw(requestParameters: ResumeScheduleRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.userId === null || requestParameters.userId === undefined) {
            throw new runtime.RequiredError('userId','Required parameter requestParameters.userId was null or undefined when calling resumeSchedule.');
        }

        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling resumeSchedule.');
        }

        const queryParameters: any = {};

        if (requestParameters.userId !== undefined) {
            queryParameters['userId'] = requestParameters.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Authorization"] = this.configuration.apiKey("X-Authorization"); // api_key authentication
        }

        const response = await this.request({
            path: `/api/scheduler/schedules/{name}/resume`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Resume a paused schedule by name
     */
    async resumeSchedule(requestParameters: ResumeScheduleRequest, initOverrides?: RequestInit): Promise<object> {
        const response = await this.resumeScheduleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create or update a schedule for a specified workflow with a corresponding start workflow request
     */
    async saveScheduleRaw(requestParameters: SaveScheduleRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.inlineObject7 === null || requestParameters.inlineObject7 === undefined) {
            throw new runtime.RequiredError('inlineObject7','Required parameter requestParameters.inlineObject7 was null or undefined when calling saveSchedule.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Authorization"] = this.configuration.apiKey("X-Authorization"); // api_key authentication
        }

        const response = await this.request({
            path: `/api/scheduler/schedules`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: InlineObject7ToJSON(requestParameters.inlineObject7),
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Create or update a schedule for a specified workflow with a corresponding start workflow request
     */
    async saveSchedule(requestParameters: SaveScheduleRequest, initOverrides?: RequestInit): Promise<object> {
        const response = await this.saveScheduleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * use sort options as sort=<field>:ASC|DESC e.g. sort=name&sort=workflowId:DESC. If order is not specified, defaults to ASC.
     * Search for workflows based on payload and other parameters
     */
    async searchV2Raw(requestParameters: SearchV2Request, initOverrides?: RequestInit): Promise<runtime.ApiResponse<SearchResultWorkflowScheduleExecutionModel>> {
        const queryParameters: any = {};

        if (requestParameters.start !== undefined) {
            queryParameters['start'] = requestParameters.start;
        }

        if (requestParameters.size !== undefined) {
            queryParameters['size'] = requestParameters.size;
        }

        if (requestParameters.sort !== undefined) {
            queryParameters['sort'] = requestParameters.sort;
        }

        if (requestParameters.freeText !== undefined) {
            queryParameters['freeText'] = requestParameters.freeText;
        }

        if (requestParameters.query !== undefined) {
            queryParameters['query'] = requestParameters.query;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Authorization"] = this.configuration.apiKey("X-Authorization"); // api_key authentication
        }

        const response = await this.request({
            path: `/api/scheduler/search/executions`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SearchResultWorkflowScheduleExecutionModelFromJSON(jsonValue));
    }

    /**
     * use sort options as sort=<field>:ASC|DESC e.g. sort=name&sort=workflowId:DESC. If order is not specified, defaults to ASC.
     * Search for workflows based on payload and other parameters
     */
    async searchV2(requestParameters: SearchV2Request = {}, initOverrides?: RequestInit): Promise<SearchResultWorkflowScheduleExecutionModel> {
        const response = await this.searchV2Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Test timeout - do not use in production
     */
    async testTimeoutRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Authorization"] = this.configuration.apiKey("X-Authorization"); // api_key authentication
        }

        const response = await this.request({
            path: `/api/scheduler/test/timeout`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Test timeout - do not use in production
     */
    async testTimeout(initOverrides?: RequestInit): Promise<void> {
        await this.testTimeoutRaw(initOverrides);
    }

}
